<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Solar Calendar with Gregorian Dates</title>
  <link rel="stylesheet" href="calendar-styles.css">
</head>
<body>
  <div class="container">
    <header>
      <h1>ðŸŒž Solar Calendar</h1>
      <div class="controls">
        <div class="control-group">
          <label for="year-input">Year:</label>
          <input type="number" id="year-input" min="1900" max="2100" />
        </div>
        <button class="theme-toggle" onclick="toggleTheme()">
          <span id="theme-icon">ðŸŒ™</span>
          <span id="theme-text">Dark Mode</span>
        </button>
      </div>
    </header>

    <div class="nav-controls">
      <button class="nav-btn" id="prev-year-btn" onclick="navigateYear(-1)">
        â—€â—€ Year
      </button>
      <button class="nav-btn" id="prev-btn" onclick="navigateMonth(-1)">
        â—€ Month
      </button>
      <div class="month-indicator" id="current-month-indicator">Month 1</div>
      <button class="nav-btn" id="next-btn" onclick="navigateMonth(1)">
        Month â–¶
      </button>
      <button class="nav-btn" id="next-year-btn" onclick="navigateYear(1)">
        Year â–¶â–¶
      </button>
    </div>

    <div class="astronomical-events" id="astronomical-events"></div>

    <div id="calendar-container"></div>
  </div>

  <script src="calendar-processor.js"></script>
  <script>
    const calendarProcessor = new CalendarProcessor();
    let currentMonth = 0; // 0-11 for Solar Months
    let selectedYear; // Will be set after data load

    function displayAstronomicalEvents() {
      if (!selectedYear) return; // Don't run if year not set
      const events = calendarProcessor.getAstronomicalEvents(selectedYear);
      const container = document.getElementById('astronomical-events');

      const eventData = [
        { key: 'vernalEquinox', title: 'ðŸŒ± Vernal Equinox', class: 'vernal', description: 'Spring begins', time: 'Solar New Year' },
        { key: 'summerSolstice', title: 'â˜€ï¸ Summer Solstice', class: 'summer', description: 'Longest day', time: 'Mid-Summer' },
        { key: 'autumnEquinox', title: 'ðŸ‚ Autumn Equinox', class: 'autumn', description: 'Fall begins', time: 'Mid-Fall' },
        { key: 'winterSolstice', title: 'â„ï¸ Winter Solstice', class: 'winter', description: 'Shortest day', time: 'Mid-Winter' }
      ];

      container.innerHTML = eventData.map(event => {
        const date = events[event.key]; // This is a UTC Date object
        if (!date || isNaN(date.getTime())) return ''; // Check for invalid date

        // Use UTC methods to display date correctly regardless of local timezone
        const monthName = calendarProcessor.gregorianMonths[date.getUTCMonth()];
        const day = date.getUTCDate();
        const dayName = calendarProcessor.dayNames[date.getUTCDay()];

        return `
          <div class="astro-event ${event.class}" onclick="navigateToEvent('${event.key}')">
            <div class="astro-event-icon">${event.title.split(' ')[0]}</div>
            <div class="astro-event-title">${event.title.substring(3)}</div>
            <div class="astro-event-date">${dayName}, ${monthName} ${day}</div>
            <div class="astro-tooltip">
              ${event.description}<br>
              <small>${event.time}</small>
            </div>
          </div>
        `;
      }).join('');
    }

    function navigateToEvent(eventKey) {
      if (!selectedYear) return;
      const events = calendarProcessor.getAstronomicalEvents(selectedYear);
      const eventDate = events[eventKey]; // UTC Date object
      if (!eventDate || isNaN(date.getTime())) return;

      // Pass the UTC Date object directly
      const solarDate = calendarProcessor.getSolarDateFromGregorian(eventDate, selectedYear);
      if (!solarDate) return;

      currentMonth = solarDate.monthIndex;
      updateDisplay(); // Update month indicator and show correct month grid

      // Highlight the specific day after display update
      setTimeout(() => {
        const eventDateStr = calendarProcessor.toISODateString(eventDate);
        const dayElement = document.querySelector(`.month.active [data-gregorian-date="${eventDateStr}"]`);
        if (dayElement) {
          dayElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          // Simple highlight effect
          dayElement.style.transition = 'none';
          dayElement.style.outline = '3px solid var(--accent-secondary)';
          dayElement.style.outlineOffset = '-3px';
          setTimeout(() => {
             dayElement.style.transition = 'outline 1.5s ease-out';
             dayElement.style.outline = '0px solid transparent';
          }, 100);
        }
      }, 100); // Allow time for month visibility change
    }

    // Formats a UTC Date object for display
    function formatGregorianDateForDisplay(date) {
        if (!date || isNaN(date.getTime())) return { month: '', day: '', dayName: ''};
        const month = calendarProcessor.gregorianMonths[date.getUTCMonth()];
        const day = date.getUTCDate();
        const dayName = calendarProcessor.dayNames[date.getUTCDay()]; // Use UTC day
        return { month, day, dayName };
    }


    function generateCalendar() {
       if (!selectedYear) {
            console.error("Cannot generate calendar without a selected year.");
            return;
       }
      const container = document.getElementById('calendar-container');
      container.innerHTML = ''; // Clear previous grid

      const today = new Date(); // Local today
      const todayStr = calendarProcessor.toISODateString(new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()))); // UTC today string

      calendarProcessor.solarMonths.forEach((month, monthIndex) => {
        const monthDiv = document.createElement('div');
        monthDiv.className = 'month'; // Initially hidden via CSS
        monthDiv.id = `month-${monthIndex}`;

        // 1. Add day headers (Sun, Mon, etc.)
        calendarProcessor.dayNames.forEach(day => {
          const header = document.createElement('div');
          header.className = 'header';
          header.textContent = day;
          monthDiv.appendChild(header);
        });

        // 2. Calculate offset for the first day
        const firstSolarDayOfMonth = month.startDay;
        const firstGregorianDate = calendarProcessor.getGregorianDateForSolarDay(selectedYear, firstSolarDayOfMonth);

        if (firstGregorianDate && !isNaN(firstGregorianDate.getTime())) {
          const firstDayOfWeek = firstGregorianDate.getUTCDay(); // 0=Sun, 1=Mon...

          // Add empty cells for padding before the 1st day
          for (let i = 0; i < firstDayOfWeek; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.className = 'day empty';
            monthDiv.appendChild(emptyDay);
          }

          // 3. Add day cells for the month
          const daysInThisMonth = calendarProcessor.getDaysInSolarMonth(selectedYear, monthIndex);

          for (let dayOfMonth = 1; dayOfMonth <= daysInThisMonth; dayOfMonth++) {
            const solarDayOfYear = month.startDay + dayOfMonth - 1;
            const gregorianDate = calendarProcessor.getGregorianDateForSolarDay(selectedYear, solarDayOfYear); // Gets UTC Date

            if (gregorianDate && !isNaN(gregorianDate.getTime())) {
              const dayDiv = document.createElement('div');
              dayDiv.className = 'day';

              const gregorianDateStr = calendarProcessor.toISODateString(gregorianDate); // YYYY-MM-DD
              dayDiv.setAttribute('data-gregorian-date', gregorianDateStr);

              // Check if it's today
              if (gregorianDateStr === todayStr) {
                dayDiv.classList.add('today');
              }

              // Check for astronomical events
              const astroEvent = calendarProcessor.checkAstronomicalEvent(gregorianDate, selectedYear);
              if (astroEvent) {
                dayDiv.classList.add(astroEvent.class); // Add class like 'vernal-equinox'
                const badge = document.createElement('div');
                badge.className = 'astro-badge';
                badge.textContent = astroEvent.icon;
                dayDiv.appendChild(badge);
              }

              // Solar day number (1-31)
              const dayNumber = document.createElement('div');
              dayNumber.className = 'day-number';
              dayNumber.textContent = dayOfMonth;
              dayDiv.appendChild(dayNumber);

              // Corresponding Gregorian date info
              const { month: gMonth, day: gDay, dayName } = formatGregorianDateForDisplay(gregorianDate);
              const gregorianInfo = document.createElement('div');
              gregorianInfo.className = 'gregorian-date';
              gregorianInfo.innerHTML = `${gMonth.substring(0,3)} ${gDay}`; // Abbreviate month
              dayDiv.appendChild(gregorianInfo);

              /* Optional: Display Gregorian Day Name
              const dayNameInfo = document.createElement('div');
              dayNameInfo.className = 'gregorian-month'; // Reusing class, maybe rename
              dayNameInfo.textContent = dayName;
              dayDiv.appendChild(dayNameInfo);
              */

              // Add click handler to link to Gregorian calendar
              dayDiv.style.cursor = 'pointer';
              dayDiv.addEventListener('click', () => {
                window.location.href = `gregorian-calendar.html?date=${gregorianDateStr}&year=${selectedYear}`;
              });

              monthDiv.appendChild(dayDiv);
            } else {
                 console.warn(`Could not calculate Gregorian date for Solar year ${selectedYear}, day ${solarDayOfYear}`);
                 // Optionally add a placeholder or error cell
                 const errorDay = document.createElement('div');
                 errorDay.className = 'day empty error';
                 errorDay.textContent = '?';
                 monthDiv.appendChild(errorDay);
            }
          } // End loop through days of month
        } else {
             console.error(`Could not get Gregorian date for first day of Solar month ${monthIndex + 1}, year ${selectedYear}`);
             // Add error message or handle gracefully
        }

        container.appendChild(monthDiv); // Append the completed month grid
      }); // End loop through solarMonths

      updateDisplay(); // Ensure the correct month is shown initially
    }

    // Updates which month grid is visible and the month indicator text
    function updateDisplay() {
       if (!selectedYear) return;
      document.querySelectorAll('.month').forEach((monthEl, index) => {
        monthEl.classList.toggle('active', index === currentMonth);
      });

      const titleData = calendarProcessor.formatSolarMonthTitle(currentMonth);
      const indicator = document.getElementById('current-month-indicator');
      indicator.innerHTML = `
        <span class="month-title-main">${titleData.main}</span>
        <span class="month-title-sub">${titleData.sub}</span>
      `;

      displayAstronomicalEvents(); // Refresh events based on the current year
    }

    // Navigate between months, handling year wrapping
    function navigateMonth(direction) {
       if (!selectedYear) return;
      let newMonth = currentMonth + direction;

      if (newMonth < 0) { // Wrap to previous year
        selectedYear--;
        if (selectedYear < 1900) selectedYear = 1900; // Boundary check
        newMonth = 11; // Last month index
        document.getElementById('year-input').value = selectedYear;
        generateCalendar(); // Regenerate calendar for the new year
      } else if (newMonth >= 12) { // Wrap to next year
        selectedYear++;
        if (selectedYear > 2100) selectedYear = 2100; // Boundary check
        newMonth = 0; // First month index
        document.getElementById('year-input').value = selectedYear;
        generateCalendar(); // Regenerate calendar for the new year
      }

      currentMonth = newMonth;
      updateDisplay(); // Show the new current month
    }

    // Navigate between years
    function navigateYear(direction) {
       if (!selectedYear) return;
      const yearInput = document.getElementById('year-input');
      let newYear = selectedYear + direction;

      // Enforce year boundaries
      if (newYear < 1900) newYear = 1900;
      if (newYear > 2100) newYear = 2100;

      yearInput.value = newYear; // Update input field
      updateYear(); // Trigger regeneration and display update
    }

    // Update calendar when year input changes
    function updateYear() {
      const yearInput = document.getElementById('year-input');
      let newYear = parseInt(yearInput.value);

      // Validate and clamp the year
      if (isNaN(newYear) || newYear < 1900) {
        newYear = 1900;
      } else if (newYear > 2100) {
        newYear = 2100;
      }
      yearInput.value = newYear; // Correct input field if needed

      if (selectedYear !== newYear) {
          selectedYear = newYear;
          // Optionally reset to the first month when year changes, or keep current month
          // currentMonth = 0;
          generateCalendar(); // Regenerate for the new year
          updateDisplay(); // Update titles and visibility
      }
    }

    // Toggle between light and dark themes
    function toggleTheme() {
      const html = document.documentElement;
      const isDark = html.getAttribute('data-theme') === 'dark';
      const newTheme = isDark ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme); // Save preference

      const icon = document.getElementById('theme-icon');
      const text = document.getElementById('theme-text');
      icon.textContent = isDark ? 'ðŸŒ™' : 'â˜€ï¸';
      text.textContent = isDark ? 'Dark Mode' : 'Light Mode';
    }

    // Initialize theme based on saved preference or default
    function initializeTheme() {
      const savedTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', savedTheme);

      const icon = document.getElementById('theme-icon');
      const text = document.getElementById('theme-text');
      if (savedTheme === 'dark') {
        icon.textContent = 'â˜€ï¸';
        text.textContent = 'Light Mode';
      } else {
         icon.textContent = 'ðŸŒ™';
         text.textContent = 'Dark Mode';
      }
    }

    // Handle URL parameters for deep linking
    function handleURLParameters() {
      const urlParams = new URLSearchParams(window.location.search);
      const targetYear = urlParams.get('year');
      const targetMonth = urlParams.get('month'); // Expecting Solar month index (0-11)
      const targetDate = urlParams.get('date'); // Expecting Gregorian YYYY-MM-DD

      let yearToSet = new Date().getFullYear(); // Default to current year

      if (targetYear) {
        let year = parseInt(targetYear);
        if (year >= 1900 && year <= 2100) {
          yearToSet = year;
        }
      }

      selectedYear = yearToSet; // Set the initial year
      document.getElementById('year-input').value = selectedYear;

      let monthToSet = 0; // Default to first month
      let dateToHighlight = null;

      if (targetMonth !== null) {
        const monthIndex = parseInt(targetMonth);
        if (monthIndex >= 0 && monthIndex < 12) {
          monthToSet = monthIndex;
        }
      } else if (targetDate) {
         // Convert Gregorian YYYY-MM-DD to Solar month index
         // Need to parse targetDate carefully, assuming it's UTC
         const dateParts = targetDate.split('-');
         if (dateParts.length === 3) {
             const year = parseInt(dateParts[0]);
             const month = parseInt(dateParts[1]) - 1; // JS month is 0-indexed
             const day = parseInt(dateParts[2]);
             // Create a UTC date object
             const gDate = new Date(Date.UTC(year, month, day));

             if (!isNaN(gDate.getTime()) && year === selectedYear) { // Ensure date is valid and in the selected year
                 const solarDate = calendarProcessor.getSolarDateFromGregorian(gDate, selectedYear);
                 if (solarDate) {
                     monthToSet = solarDate.monthIndex;
                     dateToHighlight = targetDate; // Store YYYY-MM-DD to highlight later
                 }
             } else if (year !== selectedYear) {
                 console.warn(`URL date parameter year (${year}) does not match selected year (${selectedYear}). Ignoring date parameter.`);
             }
         }
      }

      currentMonth = monthToSet; // Set the initial month

      // Return date to highlight after calendar generation
      return dateToHighlight;
    }

    // Initial setup when the DOM is ready
    document.addEventListener('DOMContentLoaded', async () => {
      initializeTheme();

      // Load essential equinox data before doing anything else
      await calendarProcessor.loadVernalEquinoxData();

      // Set initial year and month based on URL or defaults
      const dateToHighlight = handleURLParameters();

      // Setup year input listeners
      const yearInput = document.getElementById('year-input');
      // Set value again in case handleURLParameters changed selectedYear
      yearInput.value = selectedYear;
      yearInput.addEventListener('change', updateYear);
      yearInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault(); // Prevent potential form submission
          updateYear();
        }
      });

      // Generate the calendar grid for the initial year
      generateCalendar();
      // updateDisplay is called within generateCalendar's end

      // Highlight specific date from URL if applicable
      if (dateToHighlight) {
        setTimeout(() => {
          // Ensure querySelector targets the visible month
          const dayElement = document.querySelector(`.month.active [data-gregorian-date="${dateToHighlight}"]`);
          if (dayElement) {
              dayElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              // Simple highlight effect
              dayElement.style.transition = 'none';
              dayElement.style.outline = '3px solid var(--accent-secondary)';
              dayElement.style.outlineOffset = '-3px';
              setTimeout(() => {
                 dayElement.style.transition = 'outline 1.5s ease-out';
                 dayElement.style.outline = '0px solid transparent';
              }, 100);
          }
        }, 300); // Delay slightly longer to ensure layout is stable
      }
    });
  </script>
</body>
</html>

